<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=7,IE=9,IE=10">
    <meta name="viewport" content="initial-scale=1, maximum-scale=1,user-scalable=no">
    <title>StreamLayer using ArcGIS API for JavaScript and ArcGIS GeoEvent Processor for Server</title>
    <link rel="stylesheet" href="http://js.arcgis.com/3.6/js/dojo/dijit/themes/tundra/tundra.css">
    <link rel="stylesheet" href="http://js.arcgis.com/3.6/js/esri/css/esri.css">
    <style type="text/css">
      html, body {
        height: 100%; width: 100%;
        margin: 0; padding: 0;
      }
      body{
        background-color: #fff; overflow:hidden;
        font-family: sans-serif;
      }
      #map {
        width: 100%;
        height: 95%;
      }

    </style>
    <script src="http://js.arcgis.com/3.6/"></script>
  </head>
  <body class="tundra">
      <div id="map"></div>
      <div>
        <span>Connexion WebSocket à GeoEvent Processor: </span><input type="text" id="txtWsUrl" value="ws://88.190.45.92:6180/instaws" style="width: 400px"/><br/>
        <input type="button" id="cmdNewStream" value="Se connecter au flux Instagram" />
        <input type="button" id="cmdDisconnect" value="Se déconnecter du flux Instagram" />
      </div>
  </body>

  <script>
      var curTime = new Date();
      var curTimeStamp = Date.parse(curTime.toUTCString());
      var layerDefinition = {
        "geometryType": "esriGeometryPoint",
        "timeInfo": {
          "startTimeField": "DateStamp",
          "endTimeField": null,
          "trackIdField": "link",
          "timeReference": null,
          "timeInterval": 1,
          "timeIntervalUnits": "esriTimeUnitsMinutes",
          "exportOptions": {
           "useTime": true,
           "timeDataCumulative": false,
           "timeOffset": null,
           "timeOffsetUnits": null
          },
          "hasLiveData": true
         },
        "fields": [
          {
            name: "ObjectId",
            type: "esriFieldTypeOID",
            alias: "ObjectId"
          },
          {
            name: "DateStamp",
            type: "esriFieldTypeDate",
            alias: "DateStamp"
          },
          {
            name: "link",
            type: "esriFieldTypeString",
            alias: "link"
          },
          {
            name: "username",
            type: "esriFieldTypeString",
            alias: "username"
          }
        ]
      };

      var map, featureCollection, streamLayer;

      require(["esri/map",
        "esri/TimeExtent",
        "esri/layers/StreamLayer",
        "esri/InfoTemplate",
        "esri/symbols/PictureMarkerSymbol",
        "esri/symbols/SimpleLineSymbol",
        "esri/renderers/SimpleRenderer",
        "esri/renderers/TimeClassBreaksAger",
        "esri/renderers/TemporalRenderer",
        "dojo/_base/Color",
        "dojo/dom",
        "dojo/on",
        "dojo/domReady!"
      ], function(Map, TimeExtent, StreamLayer, InfoTemplate, PictureMarkerSymbol, SimpleLineSymbol, SimpleRenderer, TimeClassBreaksAger, TemporalRenderer, Color, dom, on){
          map = new Map("map",{
            basemap: "gray",
            center: [-30.402, 45.642],
            zoom: 3 
          });
          map.infoWindow.resize(330,330);


          // event listeners for button clicks
          on(dom.byId("cmdNewStream"), "click", makeNewStreamLayer);
          on(dom.byId("cmdDisconnect"), "click", disconnectStreamLayer);

          function makeStreamLayer(){
            //Make FeatureCollection to define layer without using url
            featureCollection = {
            "layerDefinition": null,
            "featureSet": {
              "features": [],
              "geometryType": "esriGeometryPoint"}
            };
            featureCollection.layerDefinition = layerDefinition;

            var layer = new StreamLayer(featureCollection, {
              socketUrl: txtWsUrl.value,
              purgeOptions: { displayCount: 500 },
              trackIdField: "Link" //featureCollection.layerDefinition.timeInfo.trackIdField,
              infoTemplate: new InfoTemplate("Published by ${Username} on ${DateStamp}", "<a href=${Link} target=_blank><img src=${Link}media ></a>")
            });
    

            //Make renderer and apply it to StreamLayer
            var renderer = makeRenderer();
            layer.setRenderer( renderer );

            //Subscribe to onMessage event of StreamLayer so can adjust map time
            layer.on("message", processMessage);
            return layer;
          }

          // Process message that StreamLayer received.
          function processMessage(message){
            var miniPicture = new PictureMarkerSymbol(message.graphic.attributes["Link"]+"media", 30, 30);
            message.graphic.setSymbol(miniPicture);
            if (featureCollection.layerDefinition.timeInfo && 
                featureCollection.layerDefinition.timeInfo.startTimeField) {
              var timestamp = message.graphic.attributes[featureCollection.layerDefinition.timeInfo.startTimeField];
              if (! map.timeExtent){
                map.setTimeExtent(new esri.TimeExtent(new Date(timestamp), new Date(timestamp)));
              } else {
                var tsEnd = Date.parse(map.timeExtent.endTime.toString());
                if (timestamp > tsEnd){
                  map.setTimeExtent(new esri.TimeExtent(map.timeExtent.startTime, new Date(timestamp)));
                }
              }
            }
          }

          // Make new StreamLayer and add it to map.
          function makeNewStreamLayer(){
            disconnectStreamLayer();
            streamLayer = makeStreamLayer();
            map.addLayer( streamLayer );
          }

          // Disconnect StreamLayer from websocket and remove it from the map
          function disconnectStreamLayer(){
            if (streamLayer){
              streamLayer.suspend();
              streamLayer.disconnect();
              streamLayer.clear();
              map.removeLayer(streamLayer);
              streamLayer = null;
              //map.timeExtent = null;
            }
          }

          // Make temporal renderer with latest observation renderer
          function makeRenderer(){
            var obsRenderer = new SimpleRenderer(
              new PictureMarkerSymbol("./insta.png",16,16)
            );

            var latestObsRenderer = new SimpleRenderer(
              new PictureMarkerSymbol("./insta.png",24,24)
            );

            var temporalRenderer = new TemporalRenderer(obsRenderer, latestObsRenderer, null, null);
            return temporalRenderer;
          }
        });
  </script>

</html> 